<!DOCTYPE html>
<html>
  <head>
    <title>Accessing Javascript objects from Clojurescript – Henry Widd's Blog – Widd Industries</title>

        <meta charset="utf-8" />
    <meta content='text/html; charset=utf-8' http-equiv='Content-Type'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0'>

    
    <meta name="description" content="There are choices as to how you access a Javascript object’s methods and properties from Clojurescript.

Starting with an appeal to authority:

In concrete terms, sounds like✓ (.-length &quot;abc&quot;)X (.-length #js {:length 3})✓ (goog.object/get #js {:length 3} &quot;length&quot;)&mdash; Mike Fikes (@mfikes) July 5, 2017


So that’s David and Mike’s opinion, now I want to look into the tradeoffs.

Firstly, I’ll try to make a clear distinction between JS data vs API: A data object is 
any object you could round-trip through JSON/stringify =&gt; JSON/parse. An object that may appear 
 to be a data object because it only contains properties (ie no methods), may not be a data object, because those
properties might be getters or setters.
If the object came via a JS library, it’s most likely not a data object unless the library documentation
explicitly says so.

That definition should be good enough for the purposes of this post, let’s ignore prototypes etc
for now.

I find the (.-length "foo") item in Mike’s list interesting. 
It’s clear in the case of the string "foo" that this is not a data object 
and btw goog.object/get will not work to access length, or any other property of a string.

But consider this example though:

(goog.object/get #js[] "length")


That returns 0, so demonstrating it is possible to use the goog.object API to access API properties.

So, we have what appears to be just a stylistic choice between that and (.-length #js[]). Why choose either one?

It’s easy to see that the goog.object one will survive advanced compilation, whereas in some 
cases the dot-access would need a type hint, for example: (.-length ^js foo).

So +1 for the goog.obj approach so far I guess.

In working with the API of some JS object, it’s quite common to both access properties and call methods:

(let [foo ^js (some-fn)
      bar-prop (.-bar foo)]
    (.methodFoo foo (inc bar-prop)))


As I pointed out before, we could have accessed bar-prop with goog.object/get, but
this example is being consistent in using dot access only for the API of foo. We could also have accessed methodFoo with 
goog.object/get (and then invoked it), but I don’t think it would be idiomatic to do so.

So, Following a rule ‘dot access only for APIs’ means the code makes a clear statement that it is
working with API, not data - regardless of whether it is just properties, or both methods and properties we need to 
use. This comes as the cost of having to remember to put type hints in. I’ve come to think
 type hints aren’t so bad, because now type hints are documented
 I think it’s easy enough to understand you just need to add ^js when you first see the js object in scope.

Yet another approach would be to use a library such as js-interop. Using that,
 you would write (j/call foo :bar 1) for the js equivalent foo.bar(1). Type hints are not needed if you use that 
 library, so it’s definitely an alternative to consider.

So, now that’s all cleared up, which dot-access is preferred, a.b.c or (.. a -b -c) …?

" />
    <meta property="og:description" content="There are choices as to how you access a Javascript object’s methods and properties from Clojurescript.

Starting with an appeal to authority:

In concrete terms, sounds like✓ (.-length &quot;abc&quot;)X (.-length #js {:length 3})✓ (goog.object/get #js {:length 3} &quot;length&quot;)&mdash; Mike Fikes (@mfikes) July 5, 2017


So that’s David and Mike’s opinion, now I want to look into the tradeoffs.

Firstly, I’ll try to make a clear distinction between JS data vs API: A data object is 
any object you could round-trip through JSON/stringify =&gt; JSON/parse. An object that may appear 
 to be a data object because it only contains properties (ie no methods), may not be a data object, because those
properties might be getters or setters.
If the object came via a JS library, it’s most likely not a data object unless the library documentation
explicitly says so.

That definition should be good enough for the purposes of this post, let’s ignore prototypes etc
for now.

I find the (.-length "foo") item in Mike’s list interesting. 
It’s clear in the case of the string "foo" that this is not a data object 
and btw goog.object/get will not work to access length, or any other property of a string.

But consider this example though:

(goog.object/get #js[] "length")


That returns 0, so demonstrating it is possible to use the goog.object API to access API properties.

So, we have what appears to be just a stylistic choice between that and (.-length #js[]). Why choose either one?

It’s easy to see that the goog.object one will survive advanced compilation, whereas in some 
cases the dot-access would need a type hint, for example: (.-length ^js foo).

So +1 for the goog.obj approach so far I guess.

In working with the API of some JS object, it’s quite common to both access properties and call methods:

(let [foo ^js (some-fn)
      bar-prop (.-bar foo)]
    (.methodFoo foo (inc bar-prop)))


As I pointed out before, we could have accessed bar-prop with goog.object/get, but
this example is being consistent in using dot access only for the API of foo. We could also have accessed methodFoo with 
goog.object/get (and then invoked it), but I don’t think it would be idiomatic to do so.

So, Following a rule ‘dot access only for APIs’ means the code makes a clear statement that it is
working with API, not data - regardless of whether it is just properties, or both methods and properties we need to 
use. This comes as the cost of having to remember to put type hints in. I’ve come to think
 type hints aren’t so bad, because now type hints are documented
 I think it’s easy enough to understand you just need to add ^js when you first see the js object in scope.

Yet another approach would be to use a library such as js-interop. Using that,
 you would write (j/call foo :bar 1) for the js equivalent foo.bar(1). Type hints are not needed if you use that 
 library, so it’s definitely an alternative to consider.

So, now that’s all cleared up, which dot-access is preferred, a.b.c or (.. a -b -c) …?

" />
    
    <meta name="author" content="Henry Widd's Blog" />

    
    <meta property="og:title" content="Accessing Javascript objects from Clojurescript" />
    <meta property="twitter:title" content="Accessing Javascript objects from Clojurescript" />
    

    <!--[if lt IE 9]>
      <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="alternate" type="application/rss+xml" title="Henry Widd's Blog - Widd Industries" href="/feed.xml" />

    <!-- Created with Jekyll Now - http://github.com/barryclark/jekyll-now -->
      <script data-ad-client="ca-pub-8297539495195641" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  </head>

  <body>
    <div class="wrapper-masthead">
      <div class="container">
        <header class="masthead clearfix">
          <a href="/" class="site-avatar"><img src="https://avatars0.githubusercontent.com/u/3070220?s=400&u=a24a48324882a361ab3dc02dd865ec9b71c079d1&v=4" /></a>

          <div class="site-info">
            <h1 class="site-name"><a href="/">Henry Widd's Blog</a></h1>
            <p class="site-description">Widd Industries</p>
          </div>

          <nav>
            <a href="/">Blog</a>
            <a href="/about">About</a>
          </nav>
        </header>
      </div>
    </div>

    <div id="main" role="main" class="container">
      <article class="post">
  <h1>Accessing Javascript objects from Clojurescript</h1>

  <div class="entry">
    <p>There are choices as to how you access a Javascript object’s methods and properties from Clojurescript.</p>

<p>Starting with an appeal to authority:</p>

<blockquote class="twitter-tweet"><p lang="en" dir="ltr">In concrete terms, sounds like<br />✓ (.-length &quot;abc&quot;)<br />X (.-length <a href="https://twitter.com/hashtag/js?src=hash&amp;ref_src=twsrc%5Etfw">#js</a> {:length 3})<br />✓ (goog.object/get <a href="https://twitter.com/hashtag/js?src=hash&amp;ref_src=twsrc%5Etfw">#js</a> {:length 3} &quot;length&quot;)</p>&mdash; Mike Fikes (@mfikes) <a href="https://twitter.com/mfikes/status/882585745424338944?ref_src=twsrc%5Etfw">July 5, 2017</a></blockquote>
<script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>So that’s David and Mike’s opinion, now I want to look into the tradeoffs.</p>

<p>Firstly, I’ll try to make a clear distinction between JS data vs API: A data object is 
any object you could round-trip through JSON/stringify =&gt; JSON/parse. An object that may appear 
 to be a data object because it only contains properties (ie no methods), may not be a data object, because those
properties might be <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get">getter</a>s or setters.
If the object came via a JS library, it’s most likely not a data object unless the library documentation
explicitly says so.</p>

<p>That definition should be good enough for the purposes of this post, let’s ignore prototypes etc
for now.</p>

<p>I find the <code class="language-plaintext highlighter-rouge">(.-length "foo")</code> item in Mike’s list interesting. 
It’s clear in the case of the string <code class="language-plaintext highlighter-rouge">"foo"</code> that this is not a data object 
and btw <code class="language-plaintext highlighter-rouge">goog.object/get</code> will not work to access <code class="language-plaintext highlighter-rouge">length</code>, or any other property of a string.</p>

<p>But consider this example though:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">goog.object/get</span><span class="w"> </span><span class="o">#</span><span class="n">js</span><span class="p">[]</span><span class="w"> </span><span class="s">"length"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>That returns <code class="language-plaintext highlighter-rouge">0</code>, so demonstrating it is possible to use the <code class="language-plaintext highlighter-rouge">goog.object</code> API to access API properties.</p>

<p>So, we have what appears to be just a stylistic choice between that and <code class="language-plaintext highlighter-rouge">(.-length #js[])</code>. Why choose either one?</p>

<p>It’s easy to see that the goog.object one will survive advanced compilation, whereas in some 
cases the dot-access would need a type hint, for example: <code class="language-plaintext highlighter-rouge">(.-length ^js foo)</code>.</p>

<p>So +1 for the goog.obj approach so far I guess.</p>

<p>In working with the API of some JS object, it’s quite common to both access properties and call methods:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">foo</span><span class="w"> </span><span class="o">^</span><span class="n">js</span><span class="w"> </span><span class="p">(</span><span class="nf">some-fn</span><span class="p">)</span><span class="w">
      </span><span class="n">bar-prop</span><span class="w"> </span><span class="p">(</span><span class="nf">.-bar</span><span class="w"> </span><span class="n">foo</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nf">.methodFoo</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="p">(</span><span class="nb">inc</span><span class="w"> </span><span class="n">bar-prop</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>As I pointed out before, we could have accessed <code class="language-plaintext highlighter-rouge">bar-prop</code> with <code class="language-plaintext highlighter-rouge">goog.object/get</code>, but
this example is being consistent in using dot access only for the API of <code class="language-plaintext highlighter-rouge">foo</code>. We could also have accessed <code class="language-plaintext highlighter-rouge">methodFoo</code> with 
goog.object/get (and then invoked it), but I don’t think it would be idiomatic to do so.</p>

<p>So, Following a rule ‘dot access only for APIs’ means the code makes a clear statement that it is
working with API, not data - regardless of whether it is just properties, or both methods and properties we need to 
use. This comes as the cost of having to remember to put type hints in. I’ve come to think
 type hints aren’t so bad, because now <a href="https://code.thheller.com/blog/shadow-cljs/2017/11/06/improved-externs-inference.html">type hints are documented</a>
 I think it’s easy enough to understand you just need to add <code class="language-plaintext highlighter-rouge">^js</code> when you first see the js object in scope.</p>

<p>Yet another approach would be to use a library such as <a href="https://github.com/applied-science/js-interop">js-interop</a>. Using that,
 you would write <code class="language-plaintext highlighter-rouge">(j/call foo :bar 1)</code> for the js equivalent <code class="language-plaintext highlighter-rouge">foo.bar(1)</code>. Type hints are not needed if you use that 
 library, so it’s definitely an alternative to consider.</p>

<p>So, now that’s all cleared up, which <a href="https://cljs.github.io/api/syntax/dot">dot-access</a> is preferred, <code class="language-plaintext highlighter-rouge">a.b.c</code> or <code class="language-plaintext highlighter-rouge">(.. a -b -c)</code> …?</p>


  </div>

  <div class="date">
    Written on March  1, 2021
  </div>

  
<div class="comments">
	<div id="disqus_thread"></div>
	<script type="text/javascript">

	    var disqus_shortname = 'widdindustries';

	    (function() {
	        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
	        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
	        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	    })();

	</script>
	<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>

</article>

    </div>

    <div class="wrapper-footer">
      <div class="container">
        <footer class="footer">
          



<a href="https://github.com/henryw374"><i class="svg-icon github"></i></a>



<a href="/feed.xml"><i class="svg-icon rss"></i></a>
<a href="https://www.twitter.com/henryw374"><i class="svg-icon twitter"></i></a>



        </footer>
      </div>
    </div>

    <style>
    #cookie-notice {padding: 0.5rem 1rem; display: none; text-align: center; position: fixed; bottom: 0; width: calc(100% - 2rem); background: #222; color: rgba(255,255,255,0.8);}
    #cookie-notice a {display: inline-block; cursor: pointer; margin-left: 0.5rem;}
    @media (max-width: 767px) {
        #cookie-notice span {display: block; padding-top: 3px; margin-bottom: 1rem;}
        #cookie-notice a {position: relative; bottom: 4px;}
    }
</style>
<div id="cookie-notice"><span>We would like to use third party cookies and scripts to improve the functionality of this website.</span><a id="cookie-notice-accept" class="btn btn-primary btn-sm">Approve</a><a href="/privacy" class="btn btn-primary btn-sm">More info</a></div>
<script>
    function createCookie(name,value,days) {
        var expires = "";
        if (days) {
            var date = new Date();
            date.setTime(date.getTime() + (days*24*60*60*1000));
            expires = "; expires=" + date.toUTCString();
        }
        document.cookie = name + "=" + value + expires + "; path=/";
    }
    function readCookie(name) {
        var nameEQ = name + "=";
        var ca = document.cookie.split(';');
        for(var i=0;i < ca.length;i++) {
            var c = ca[i];
            while (c.charAt(0)==' ') c = c.substring(1,c.length);
            if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length,c.length);
        }
        return null;
    }
    function eraseCookie(name) {
        createCookie(name,"",-1);
    }

    if(readCookie('cookie-notice-dismissed')=='true') {
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
		(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
		m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
		})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

		ga('create', 'UA-131917038-1', 'auto');
		ga('send', 'pageview', {
		  'page': '/clojurescript-jsinterop/',
		  'title': 'Accessing Javascript objects from Clojurescript'
		});
    } else {
        document.getElementById('cookie-notice').style.display = 'block';
    }
    document.getElementById('cookie-notice-accept').addEventListener("click",function() {
        createCookie('cookie-notice-dismissed','true',31);
        document.getElementById('cookie-notice').style.display = 'none';
        location.reload();
    });

</script>

  </body>
</html>
